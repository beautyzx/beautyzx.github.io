<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft é¢¨æ ¼å»ºé€ å†’éšª</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            pointer-events: auto;
            font-size: 14px;
        }

        .hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #666;
        }

        .hotbar-slot {
            width: 48px;
            height: 48px;
            border: 2px solid #555;
            background: rgba(139, 69, 19, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            position: relative;
            transition: all 0.2s;
        }

        .hotbar-slot.selected {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .hotbar-slot .count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 2px;
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background: white;
            box-shadow: 0 0 4px black;
        }

        .crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 2px;
            background: white;
            box-shadow: 0 0 4px black;
        }

        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: auto;
        }

        .health-bar {
            display: flex;
            gap: 2px;
            margin: 5px 0;
        }

        .heart {
            font-size: 16px;
            color: #ff4444;
        }

        .heart.empty {
            color: #444;
        }

        .shop-ui {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 69, 19, 0.95);
            border: 4px solid #8B4513;
            border-radius: 12px;
            padding: 30px;
            color: white;
            display: none;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        .shop-header {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .shop-item {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .shop-item:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .shop-item-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .shop-item-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .shop-item-price {
            color: #FFD700;
            font-size: 14px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: auto;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }

        .weapon-swing {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .block-outline {
            border: 2px solid white !important;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5) !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="loading" id="loading">
            ğŸ® è¼‰å…¥ Minecraft ä¸–ç•Œä¸­...<br>
            <small>è«‹ç¨å€™</small>
        </div>
        
        <div id="ui" style="display: none;">
            <div class="crosshair"></div>
            
            <div class="stats">
                <div><strong>ğŸƒâ€â™‚ï¸ ç©å®¶ç‹€æ…‹</strong></div>
                <div class="health-bar" id="healthBar">
                    <span class="heart">â¤ï¸</span>
                    <span class="heart">â¤ï¸</span>
                    <span class="heart">â¤ï¸</span>
                    <span class="heart">â¤ï¸</span>
                    <span class="heart">â¤ï¸</span>
                </div>
                <div>ğŸ’° é‡‘å¹£: <span id="playerGold">0</span></div>
                <div>â­ ç­‰ç´š: <span id="playerLevel">1</span></div>
                <div>ğŸ“ ä½ç½®: <span id="playerPos">0, 0, 0</span></div>
            </div>

            <div class="controls">
                <div><strong>ğŸ® æ“ä½œèªªæ˜</strong></div>
                <div>WASD - ç§»å‹• (èµ°è·¯)</div>
                <div>ç©ºç™½éµ - è·³èº</div>
                <div>æ»‘é¼  - è½‰å‹•è¦–è§’</div>
                <div>å·¦éµ - æ”»æ“Š/ç ´å£</div>
                <div>å³éµ - æ”¾ç½®æ–¹å¡Š</div>
                <div>å³éµé€£é»2æ¬¡ - å¿«é€Ÿç ´å£</div>
                <div>1-9 - é¸æ“‡ç‰©å“</div>
                <div>E - èˆ‡NPCäº’å‹•</div>
                <div>Shift - æ½›è¡Œ</div>
            </div>
        </div>

        <div class="hotbar">
            <div class="hotbar-slot selected" data-slot="0">
                ğŸ§±
                <span class="count">64</span>
            </div>
            <div class="hotbar-slot" data-slot="1">
                ğŸŒ³
                <span class="count">0</span>
            </div>
            <div class="hotbar-slot" data-slot="2">
                ğŸª¨
                <span class="count">0</span>
            </div>
            <div class="hotbar-slot" data-slot="3">
                â›ï¸
                <span class="count">1</span>
            </div>
            <div class="hotbar-slot" data-slot="4">
                âš”ï¸
                <span class="count">1</span>
            </div>
            <div class="hotbar-slot" data-slot="5">
                ğŸ¹
                <span class="count">0</span>
            </div>
            <div class="hotbar-slot" data-slot="6">
                ğŸ–
                <span class="count">3</span>
            </div>
            <div class="hotbar-slot" data-slot="7">
                ğŸ’
                <span class="count">0</span>
            </div>
            <div class="hotbar-slot" data-slot="8">
                ğŸ”¥
                <span class="count">0</span>
            </div>
        </div>

        <div class="shop-ui" id="shopUI">
            <div class="shop-header">ğŸª æ‘èŠå•†åº—</div>
            <div class="shop-grid" id="shopGrid">
                <div class="shop-item" data-item="iron_sword" data-price="50">
                    <div class="shop-item-icon">ğŸ—¡ï¸</div>
                    <div class="shop-item-name">éµåŠ</div>
                    <div class="shop-item-price">ğŸ’° 50 é‡‘å¹£</div>
                </div>
                <div class="shop-item" data-item="diamond_pickaxe" data-price="100">
                    <div class="shop-item-icon">â›ï¸</div>
                    <div class="shop-item-name">é‘½çŸ³é¬</div>
                    <div class="shop-item-price">ğŸ’° 100 é‡‘å¹£</div>
                </div>
                <div class="shop-item" data-item="bow" data-price="75">
                    <div class="shop-item-icon">ğŸ¹</div>
                    <div class="shop-item-name">å¼“ç®­</div>
                    <div class="shop-item-price">ğŸ’° 75 é‡‘å¹£</div>
                </div>
                <div class="shop-item" data-item="armor" data-price="150">
                    <div class="shop-item-icon">ğŸ›¡ï¸</div>
                    <div class="shop-item-name">éµç›”ç”²</div>
                    <div class="shop-item-price">ğŸ’° 150 é‡‘å¹£</div>
                </div>
                <div class="shop-item" data-item="food" data-price="10">
                    <div class="shop-item-icon">ğŸ</div>
                    <div class="shop-item-name">éºµåŒ…</div>
                    <div class="shop-item-price">ğŸ’° 10 é‡‘å¹£</div>
                </div>
                <div class="shop-item" data-item="blocks" data-price="5">
                    <div class="shop-item-icon">ğŸ§±</div>
                    <div class="shop-item-name">çŸ³ç£š x10</div>
                    <div class="shop-item-price">ğŸ’° 5 é‡‘å¹£</div>
                </div>
            </div>
            <button onclick="closeShop()" style="margin-top: 20px; padding: 10px 20px; background: #8B4513; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">é—œé–‰å•†åº—</button>
        </div>

        <div class="weapon-swing" id="weaponSwing">âš”ï¸</div>
    </div>

    <script>
        // éŠæˆ²ç‹€æ…‹
        const gameState = {
            scene: null,
            camera: null,
            renderer: null,
            player: null,
            world: [],
            blocks: new Map(),
            npcs: [],
            village: null,
            inventory: [64, 0, 0, 1, 1, 0, 3, 0, 0], // ç‰©å“æ•¸é‡
            selectedSlot: 0,
            playerStats: {
                health: 100,
                maxHealth: 100,
                level: 1,
                gold: 0,
                attack: 10
            },
            worldSize: 100,
            chunkSize: 16,
            loadedChunks: new Set(),
            keys: {},
            mouse: { x: 0, y: 0, locked: false },
            camera: {
                rotation: { x: 0, y: 0 },
                distance: 0
            },
            controls: {
                moveSpeed: 0.15,
                jumpForce: 0.2,
                mouseSensitivity: 0.002
            },
            rightClickCount: 0,
            rightClickTimer: null,
            weaponCooldown: 0,
            isNearShop: false,
            highlightedBlock: null
        };

        // æ–¹å¡Šé¡å‹
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            WATER: 7,
            COBBLESTONE: 8,
            PLANKS: 9
        };

        const blockTextures = {
            [BlockType.GRASS]: { color: 0x7CB342, name: 'è‰åœ°' },
            [BlockType.DIRT]: { color: 0x8D6E63, name: 'æ³¥åœŸ' },
            [BlockType.STONE]: { color: 0x757575, name: 'çŸ³é ­' },
            [BlockType.WOOD]: { color: 0x8D6E63, name: 'æœ¨é ­' },
            [BlockType.LEAVES]: { color: 0x4CAF50, name: 'æ¨¹è‘‰' },
            [BlockType.SAND]: { color: 0xFFC107, name: 'æ²™å­' },
            [BlockType.WATER]: { color: 0x2196F3, name: 'æ°´' },
            [BlockType.COBBLESTONE]: { color: 0x616161, name: 'åœ“çŸ³' },
            [BlockType.PLANKS]: { color: 0xA1887F, name: 'æœ¨æ¿' }
        };

        // å™ªè²å‡½æ•¸
        function noise(x, z) {
            let value = 0;
            let amplitude = 1;
            let frequency = 0.01;
            
            for (let i = 0; i < 4; i++) {
                value += Math.sin(x * frequency) * Math.cos(z * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value;
        }

        // åœ°å½¢ç”Ÿæˆ
        function getHeight(x, z) {
            const baseHeight = 32;
            const heightVariation = noise(x, z) * 8;
            return Math.floor(baseHeight + heightVariation);
        }

        function getBlockType(x, y, z) {
            const height = getHeight(x, z);
            
            if (y > height) return BlockType.AIR;
            if (y === height) return BlockType.GRASS;
            if (y > height - 3) return BlockType.DIRT;
            if (y > height - 10) return BlockType.STONE;
            return BlockType.STONE;
        }

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            console.log('ğŸ® åˆå§‹åŒ– Minecraft ä¸–ç•Œ...');
            
            try {
                setupThreeJS();
                setupLighting();
                setupCamera();
                setupControls();
                generateWorld();
                createPlayer();
                createVillage();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                
                startGameLoop();
                updateUI();
                
                console.log('âœ… éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼');
                
            } catch (error) {
                console.error('âŒ éŠæˆ²åˆå§‹åŒ–å¤±æ•—:', error);
                document.getElementById('loading').innerHTML = `âŒ è¼‰å…¥å¤±æ•—<br><small>${error.message}</small>`;
            }
        }

        function setupThreeJS() {
            const canvas = document.getElementById('gameCanvas');
            
            gameState.scene = new THREE.Scene();
            gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            gameState.renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false // é—œé–‰æŠ—é‹¸é½’æå‡æ€§èƒ½
            });
            
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            gameState.renderer.setClearColor(0x87CEEB); // å¤©ç©ºè—
            gameState.renderer.shadowMap.enabled = true;
            gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // è¨­ç½®éœ§æ•ˆæœ
            gameState.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
        }

        function setupLighting() {
            // ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            gameState.scene.add(ambientLight);

            // å¤ªé™½å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            
            // é™°å½±è¨­ç½®
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            
            gameState.scene.add(directionalLight);
        }

        function setupCamera() {
            gameState.camera.position.set(0, 35, 0);
            gameState.camera.rotation.order = 'YXZ';
        }

        function setupControls() {
            // éµç›¤äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                
                // æ•¸å­—éµé¸æ“‡ç‰©å“
                if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                    const slot = parseInt(e.code.replace('Digit', '')) - 1;
                    selectSlot(slot);
                }
                
                // Eéµèˆ‡NPCäº’å‹•
                if (e.code === 'KeyE' && gameState.isNearShop) {
                    toggleShop();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            // æ»‘é¼ äº‹ä»¶
            document.addEventListener('mousedown', (e) => {
                if (!gameState.mouse.locked) {
                    canvas.requestPointerLock();
                    return;
                }
                
                if (e.button === 0) { // å·¦éµ
                    handleLeftClick();
                } else if (e.button === 2) { // å³éµ
                    handleRightClick();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!gameState.mouse.locked) return;
                
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;
                
                gameState.camera.rotation.y -= movementX * gameState.controls.mouseSensitivity;
                gameState.camera.rotation.x -= movementY * gameState.controls.mouseSensitivity;
                
                // é™åˆ¶ä¸Šä¸‹è¦–è§’
                gameState.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, gameState.camera.rotation.x));
            });
            
            // æ»‘é¼ é–å®šäº‹ä»¶
            document.addEventListener('pointerlockchange', () => {
                gameState.mouse.locked = document.pointerLockElement === document.getElementById('gameCanvas');
            });
            
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // è¦–çª—å¤§å°èª¿æ•´
            window.addEventListener('resize', () => {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function generateWorld() {
            console.log('ğŸŒ ç”Ÿæˆä¸–ç•Œåœ°å½¢...');
            
            // ç”Ÿæˆåˆå§‹å€å¡Š
            for (let chunkX = -2; chunkX <= 2; chunkX++) {
                for (let chunkZ = -2; chunkZ <= 2; chunkZ++) {
                    generateChunk(chunkX, chunkZ);
                }
            }
        }

        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            if (gameState.loadedChunks.has(chunkKey)) return;
            
            gameState.loadedChunks.add(chunkKey);
            
            const startX = chunkX * gameState.chunkSize;
            const startZ = chunkZ * gameState.chunkSize;
            
            for (let x = startX; x < startX + gameState.chunkSize; x++) {
                for (let z = startZ; z < startZ + gameState.chunkSize; z++) {
                    const height = getHeight(x, z);
                    
                    // ç”Ÿæˆåœ°é¢
                    for (let y = 0; y <= height; y++) {
                        const blockType = getBlockType(x, y, z);
                        if (blockType !== BlockType.AIR) {
                            createBlock(x, y, z, blockType);
                        }
                    }
                    
                    // ç”Ÿæˆæ¨¹æœ¨
                    if (Math.random() < 0.02 && height > 30) {
                        generateTree(x, height + 1, z);
                    }
                }
            }
        }

        function generateTree(x, y, z) {
            // æ¨¹å¹¹
            for (let i = 0; i < 4; i++) {
                createBlock(x, y + i, z, BlockType.WOOD);
            }
            
            // æ¨¹è‘‰
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = 3; dy <= 5; dy++) {
                        if (Math.abs(dx) + Math.abs(dz) <= 2 + Math.random()) {
                            createBlock(x + dx, y + dy, z + dz, BlockType.LEAVES);
                        }
                    }
                }
            }
        }

        function createVillage() {
            console.log('ğŸ˜ï¸ ç”Ÿæˆæ‘èŠ...');
            
            const villageX = 20;
            const villageZ = 20;
            const villageSize = 10;
            
            // å¹³æ•´åœ°é¢
            for (let x = villageX - villageSize; x <= villageX + villageSize; x++) {
                for (let z = villageZ - villageSize; z <= villageZ + villageSize; z++) {
                    const height = getHeight(x, z);
                    
                    // æ¸…é™¤ç¾æœ‰æ–¹å¡Š
                    for (let y = height + 1; y <= height + 10; y++) {
                        removeBlock(x, y, z);
                    }
                    
                    // é‹ªè¨­åœ°é¢
                    createBlock(x, height, z, BlockType.COBBLESTONE);
                }
            }
            
            // å»ºé€ æˆ¿å±‹
            buildHouse(villageX - 5, getHeight(villageX - 5, villageZ - 5) + 1, villageZ - 5);
            buildHouse(villageX + 5, getHeight(villageX + 5, villageZ - 5) + 1, villageZ - 5);
            buildHouse(villageX - 5, getHeight(villageX - 5, villageZ + 5) + 1, villageZ + 5);
            
            // å»ºé€ å•†åº—
            buildShop(villageX, getHeight(villageX, villageZ) + 1, villageZ);
            
            // å‰µå»ºå•†åº—NPC
            createShopNPC(villageX, getHeight(villageX, villageZ) + 2, villageZ);
        }

        function buildHouse(x, y, z) {
            // ç‰†å£
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = 0; dy <= 3; dy++) {
                        if (dx === -2 || dx === 2 || dz === -2 || dz === 2) {
                            if (dy === 0 || dy === 3 || (dx !== 0 && dz !== 0)) {
                                createBlock(x + dx, y + dy, z + dz, BlockType.PLANKS);
                            }
                        }
                    }
                }
            }
            
            // å±‹é ‚
            for (let dx = -3; dx <= 3; dx++) {
                for (let dz = -3; dz <= 3; dz++) {
                    if (Math.abs(dx) + Math.abs(dz) <= 4) {
                        createBlock(x + dx, y + 4, z + dz, BlockType.WOOD);
                    }
                }
            }
        }

        function buildShop(x, y, z) {
            // è¼ƒå¤§çš„å•†åº—å»ºç¯‰
            for (let dx = -3; dx <= 3; dx++) {
                for (let dz = -3; dz <= 3; dz++) {
                    for (let dy = 0; dy <= 4; dy++) {
                        if (dx === -3 || dx === 3 || dz === -3 || dz === 3) {
                            createBlock(x + dx, y + dy, z + dz, BlockType.COBBLESTONE);
                        }
                    }
                }
            }
            
            // å±‹é ‚
            for (let dx = -4; dx <= 4; dx++) {
                for (let dz = -4; dz <= 4; dz++) {
                    if (Math.abs(dx) + Math.abs(dz) <= 6) {
                        createBlock(x + dx, y + 5, z + dz, BlockType.WOOD);
                    }
                }
            }
            
            // é–€å£
            removeBlock(x, y + 1, z - 3);
            removeBlock(x, y + 2, z - 3);
        }

        function createShopNPC(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const npc = new THREE.Mesh(geometry, material);
            
            npc.position.set(x, y, z);
            npc.userData = { type: 'shop', interactRange: 5 };
            npc.castShadow = true;
            
            // NPCé ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.2, 0);
            npc.add(head);
            
            gameState.scene.add(npc);
            gameState.npcs.push(npc);
            
            console.log('ğŸ§‘â€ğŸ’¼ å•†åº—NPCå·²å‰µå»º');
        }

        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (gameState.blocks.has(key)) return;
            
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ 
                color: blockTextures[type].color
            });
            
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.userData = { 
                type: type, 
                x: x, 
                y: y, 
                z: z,
                blockKey: key
            };
            
            block.castShadow = true;
            block.receiveShadow = true;
            
            gameState.scene.add(block);
            gameState.blocks.set(key, block);
            gameState.world.push(block);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = gameState.blocks.get(key);
            
            if (block) {
                gameState.scene.remove(block);
                gameState.blocks.delete(key);
                gameState.world = gameState.world.filter(b => b !== block);
                
                // çµ¦äºˆè³‡æº
                const blockType = block.userData.type;
                if (blockType === BlockType.WOOD) {
                    gameState.inventory[1]++;
                    gameState.playerStats.gold += 2;
                } else if (blockType === BlockType.STONE) {
                    gameState.inventory[2]++;
                    gameState.playerStats.gold += 1;
                } else if (blockType === BlockType.LEAVES) {
                    if (Math.random() < 0.1) {
                        gameState.inventory[1]++; // æœ‰æ©Ÿæœƒæ‰è½æœ¨é ­
                    }
                }
                
                updateUI();
                return true;
            }
            return false;
        }

        function createPlayer() {
            console.log('ğŸ‘¤ å‰µå»ºç©å®¶...');
            
            const group = new THREE.Group();
            
            // èº«é«”
            const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            group.add(body);
            
            // é ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            group.add(head);
            
            // æ‰‹è‡‚
            const armGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.5, 0);
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.5, 0);
            group.add(rightArm);
            
            // è…¿
            const legGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2196F3 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, -0.5, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, -0.5, 0);
            group.add(rightLeg);
            
            // è¨­ç½®åˆå§‹ä½ç½®
            const spawnHeight = getHeight(0, 0) + 3;
            group.position.set(0, spawnHeight, 0);
            group.userData = { 
                velocityY: 0,
                onGround: false,
                health: 100
            };
            
            group.castShadow = true;
            gameState.scene.add(group);
            gameState.player = group;
        }

        function getTargetedBlock() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), gameState.camera);
            
            const intersects = raycaster.intersectObjects(gameState.world);
            
            if (intersects.length > 0) {
                return {
                    block: intersects[0].object,
                    face: intersects[0].face,
                    point: intersects[0].point
                };
            }
            
            return null;
        }

        function highlightBlock() {
            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
            if (gameState.highlightedBlock) {
                gameState.highlightedBlock.material.emissive.setHex(0x000000);
                gameState.highlightedBlock = null;
            }
            
            const target = getTargetedBlock();
            if (target) {
                gameState.highlightedBlock = target.block;
                target.block.material.emissive.setHex(0x444444);
            }
        }

        function handleLeftClick() {
            if (gameState.weaponCooldown > 0) return;
            
            // æ®åŠå‹•ç•«
            playWeaponSwing();
            gameState.weaponCooldown = 500; // 0.5ç§’å†·å»
            
            const target = getTargetedBlock();
            if (target) {
                const block = target.block;
                const userData = block.userData;
                
                // ç ´å£æ–¹å¡Š
                if (removeBlock(userData.x, userData.y, userData.z)) {
                    console.log(`ğŸ”¨ ç ´å£äº† ${blockTextures[userData.type].name}`);
                }
            }
        }

        function handleRightClick() {
            gameState.rightClickCount++;
            
            // é‡ç½®è¨ˆæ™‚å™¨
            clearTimeout(gameState.rightClickTimer);
            gameState.rightClickTimer = setTimeout(() => {
                if (gameState.rightClickCount === 1) {
                    // å–®æ¬¡å³éµ - æ”¾ç½®æ–¹å¡Š
                    placeBlock();
                } else if (gameState.rightClickCount >= 2) {
                    // é›™æ“Šå³éµ - å¿«é€Ÿç ´å£
                    quickBreak();
                }
                gameState.rightClickCount = 0;
            }, 300);
        }

        function placeBlock() {
            if (gameState.inventory[gameState.selectedSlot] <= 0) return;
            
            const target = getTargetedBlock();
            if (!target) return;
            
            const face = target.face;
            const block = target.block;
            const pos = block.position.clone();
            
            // æ ¹æ“šé¢çš„æ³•å‘é‡æ±ºå®šæ–°æ–¹å¡Šä½ç½®
            pos.add(face.normal);
            
            // æª¢æŸ¥ä½ç½®æ˜¯å¦è¢«ç©å®¶å ç”¨
            const playerPos = gameState.player.position;
            const distance = pos.distanceTo(playerPos);
            if (distance < 1.5) return; // å¤ªé è¿‘ç©å®¶
            
            // æª¢æŸ¥ä½ç½®æ˜¯å¦å·²è¢«å ç”¨
            const key = `${Math.round(pos.x)},${Math.round(pos.y)},${Math.round(pos.z)}`;
            if (gameState.blocks.has(key)) return;
            
            // æ”¾ç½®æ–¹å¡Š
            const blockType = getSelectedBlockType();
            if (blockType !== null) {
                createBlock(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z), blockType);
                gameState.inventory[gameState.selectedSlot]--;
                updateUI();
                console.log(`ğŸ§± æ”¾ç½®äº† ${blockTextures[blockType].name}`);
            }
        }

        function quickBreak() {
            const target = getTargetedBlock();
            if (target) {
                const block = target.block;
                const userData = block.userData;
                
                if (removeBlock(userData.x, userData.y, userData.z)) {
                    console.log(`ğŸ’¥ å¿«é€Ÿç ´å£äº† ${blockTextures[userData.type].name}`);
                }
            }
        }

        function getSelectedBlockType() {
            switch (gameState.selectedSlot) {
                case 0: return BlockType.COBBLESTONE;
                case 1: return BlockType.WOOD;
                case 2: return BlockType.STONE;
                default: return null;
            }
        }

        function playWeaponSwing() {
            const weaponSwing = document.getElementById('weaponSwing');
            const selectedItem = gameState.inventory[gameState.selectedSlot];
            
            let weaponIcon = 'âœŠ';
            if (gameState.selectedSlot === 3) weaponIcon = 'â›ï¸';
            else if (gameState.selectedSlot === 4) weaponIcon = 'âš”ï¸';
            else if (gameState.selectedSlot === 5) weaponIcon = 'ğŸ¹';
            
            weaponSwing.textContent = weaponIcon;
            weaponSwing.style.opacity = '1';
            weaponSwing.style.transform = 'translate(-50%, -50%) rotate(-45deg) scale(1.2)';
            
            setTimeout(() => {
                weaponSwing.style.opacity = '0';
                weaponSwing.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
            }, 200);
        }

        function updatePlayer() {
            if (!gameState.player) return;
            
            const moveSpeed = gameState.controls.moveSpeed;
            const jumpForce = gameState.controls.jumpForce;
            
            const playerPos = gameState.player.position;
            const newPos = playerPos.clone();
            
            // ç§»å‹•å‘é‡
            const moveVector = new THREE.Vector3();
            
            // æ ¹æ“šç›¸æ©Ÿæ–¹å‘è¨ˆç®—ç§»å‹•
            if (gameState.keys['KeyW']) moveVector.z -= 1;
            if (gameState.keys['KeyS']) moveVector.z += 1;
            if (gameState.keys['KeyA']) moveVector.x -= 1;
            if (gameState.keys['KeyD']) moveVector.x += 1;
            
            // æ­£è¦åŒ–ç§»å‹•å‘é‡
            if (moveVector.length() > 0) {
                moveVector.normalize();
                
                // æ ¹æ“šç›¸æ©ŸYè»¸æ—‹è½‰èª¿æ•´ç§»å‹•æ–¹å‘
                moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.camera.rotation.y);
                
                // æ½›è¡Œæ™‚ç§»å‹•è¼ƒæ…¢
                const actualMoveSpeed = gameState.keys['ShiftLeft'] ? moveSpeed * 0.5 : moveSpeed;
                newPos.add(moveVector.multiplyScalar(actualMoveSpeed));
            }
            
            // è·³èº
            if (gameState.keys['Space'] && gameState.player.userData.onGround) {
                gameState.player.userData.velocityY = jumpForce;
                gameState.player.userData.onGround = false;
            }
            
            // é‡åŠ›
            gameState.player.userData.velocityY -= 0.01;
            newPos.y += gameState.player.userData.velocityY;
            
            // åœ°é¢ç¢°æ’æª¢æ¸¬
            const groundHeight = getGroundHeight(newPos.x, newPos.z) + 1.5;
            if (newPos.y <= groundHeight) {
                newPos.y = groundHeight;
                gameState.player.userData.velocityY = 0;
                gameState.player.userData.onGround = true;
            } else {
                gameState.player.userData.onGround = false;
            }
            
            // é‚Šç•Œæª¢æ¸¬
            const boundary = gameState.worldSize / 2;
            newPos.x = Math.max(-boundary, Math.min(boundary, newPos.x));
            newPos.z = Math.max(-boundary, Math.min(boundary, newPos.z));
            
            gameState.player.position.copy(newPos);
            
            // æª¢æŸ¥æ˜¯å¦é è¿‘å•†åº—
            checkNearShop();
        }

        function getGroundHeight(x, z) {
            let maxHeight = 0;
            
            // æª¢æŸ¥ç©å®¶è…³ä¸‹çš„æ–¹å¡Š
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const checkX = Math.floor(x + dx);
                    const checkZ = Math.floor(z + dz);
                    
                    for (let y = 60; y >= 0; y--) {
                        const key = `${checkX},${y},${checkZ}`;
                        if (gameState.blocks.has(key)) {
                            maxHeight = Math.max(maxHeight, y);
                            break;
                        }
                    }
                }
            }
            
            return maxHeight;
        }

        function checkNearShop() {
            let nearShop = false;
            
            gameState.npcs.forEach(npc => {
                if (npc.userData.type === 'shop') {
                    const distance = gameState.player.position.distanceTo(npc.position);
                    if (distance < npc.userData.interactRange) {
                        nearShop = true;
                    }
                }
            });
            
            if (nearShop !== gameState.isNearShop) {
                gameState.isNearShop = nearShop;
                if (nearShop) {
                    showMessage('æŒ‰ E éµèˆ‡å•†åº—NPCäº’å‹•');
                }
            }
        }

        function updateCamera() {
            if (!gameState.player) return;
            
            const playerPos = gameState.player.position;
            
            // ç¬¬ä¸€äººç¨±è¦–è§’
            gameState.camera.position.copy(playerPos);
            gameState.camera.position.y += 1.6; // çœ¼ç›é«˜åº¦
            
            // æ‡‰ç”¨æ—‹è½‰
            gameState.camera.rotation.x = gameState.camera.rotation.x;
            gameState.camera.rotation.y = gameState.camera.rotation.y;
        }

        function startGameLoop() {
            function gameLoop() {
                requestAnimationFrame(gameLoop);
                
                // æ›´æ–°æ­¦å™¨å†·å»
                if (gameState.weaponCooldown > 0) {
                    gameState.weaponCooldown -= 16; // å‡è¨­60FPS
                }
                
                updatePlayer();
                updateCamera();
                highlightBlock();
                
                // å‹•æ…‹è¼‰å…¥å€å¡Š
                loadNearbyChunks();
                
                gameState.renderer.render(gameState.scene, gameState.camera);
            }
            
            gameLoop();
        }

        function loadNearbyChunks() {
            if (!gameState.player) return;
            
            const playerPos = gameState.player.position;
            const chunkX = Math.floor(playerPos.x / gameState.chunkSize);
            const chunkZ = Math.floor(playerPos.z / gameState.chunkSize);
            
            const loadDistance = 3;
            
            for (let x = chunkX - loadDistance; x <= chunkX + loadDistance; x++) {
                for (let z = chunkZ - loadDistance; z <= chunkZ + loadDistance; z++) {
                    generateChunk(x, z);
                }
            }
        }

        function selectSlot(slot) {
            if (slot < 0 || slot >= gameState.inventory.length) return;
            
            document.querySelector('.hotbar-slot.selected')?.classList.remove('selected');
            document.querySelector(`[data-slot="${slot}"]`)?.classList.add('selected');
            gameState.selectedSlot = slot;
            
            console.log(`ğŸ“¦ é¸æ“‡ç‰©å“æ§½ ${slot + 1}`);
        }

        function updateUI() {
            // æ›´æ–°èƒŒåŒ…
            const hotbarSlots = document.querySelectorAll('.hotbar-slot');
            hotbarSlots.forEach((slot, index) => {
                const count = slot.querySelector('.count');
                if (count) {
                    count.textContent = gameState.inventory[index] || 0;
                }
            });
            
            // æ›´æ–°çµ±è¨ˆ
            document.getElementById('playerGold').textContent = gameState.playerStats.gold;
            document.getElementById('playerLevel').textContent = gameState.playerStats.level;
            
            // æ›´æ–°ä½ç½®
            if (gameState.player) {
                const pos = gameState.player.position;
                document.getElementById('playerPos').textContent = 
                    `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
            }
            
            // æ›´æ–°è¡€é‡
            updateHealthBar();
        }

        function updateHealthBar() {
            const hearts = document.querySelectorAll('.heart');
            const maxHearts = hearts.length;
            const healthPerHeart = gameState.playerStats.maxHealth / maxHearts;
            const fullHearts = Math.floor(gameState.playerStats.health / healthPerHeart);
            
            hearts.forEach((heart, index) => {
                heart.classList.toggle('empty', index >= fullHearts);
            });
        }

        function showMessage(text) {
            // ç°¡å–®çš„è¨Šæ¯é¡¯ç¤º
            const existingMsg = document.querySelector('.game-message');
            if (existingMsg) existingMsg.remove();
            
            const message = document.createElement('div');
            message.className = 'game-message';
            message.style.cssText = `
                position: fixed;
                top: 70%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 16px;
                z-index: 1000;
                pointer-events: none;
            `;
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 3000);
        }

        // å•†åº—ç³»çµ±
        function toggleShop() {
            const shopUI = document.getElementById('shopUI');
            const isVisible = shopUI.style.display !== 'none';
            shopUI.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                document.exitPointerLock();
                gameState.mouse.locked = false;
            }
        }

        function closeShop() {
            document.getElementById('shopUI').style.display = 'none';
        }

        // å•†åº—ç‰©å“è³¼è²·
        document.addEventListener('click', (e) => {
            const shopItem = e.target.closest('.shop-item');
            if (shopItem) {
                const itemType = shopItem.dataset.item;
                const price = parseInt(shopItem.dataset.price);
                buyItem(itemType, price);
            }
        });

        function buyItem(itemType, price) {
            if (gameState.playerStats.gold < price) {
                showMessage(`ğŸ’° é‡‘å¹£ä¸è¶³ï¼éœ€è¦ ${price} é‡‘å¹£`);
                return;
            }
            
            gameState.playerStats.gold -= price;
            
            switch (itemType) {
                case 'iron_sword':
                    gameState.inventory[4]++;
                    gameState.playerStats.attack += 5;
                    showMessage('ğŸ—¡ï¸ è³¼è²·äº†éµåŠï¼æ”»æ“ŠåŠ›æå‡ï¼');
                    break;
                case 'diamond_pickaxe':
                    gameState.inventory[3]++;
                    showMessage('â›ï¸ è³¼è²·äº†é‘½çŸ³é¬ï¼');
                    break;
                case 'bow':
                    gameState.inventory[5]++;
                    showMessage('ğŸ¹ è³¼è²·äº†å¼“ç®­ï¼');
                    break;
                case 'armor':
                    gameState.playerStats.maxHealth += 20;
                    gameState.playerStats.health = gameState.playerStats.maxHealth;
                    showMessage('ğŸ›¡ï¸ è³¼è²·äº†ç›”ç”²ï¼è¡€é‡æå‡ï¼');
                    break;
                case 'food':
                    gameState.inventory[6] += 5;
                    showMessage('ğŸ è³¼è²·äº†éºµåŒ…ï¼');
                    break;
                case 'blocks':
                    gameState.inventory[0] += 10;
                    showMessage('ğŸ§± è³¼è²·äº†çŸ³ç£šï¼');
                    break;
            }
            
            updateUI();
        }

        // éŠæˆ²å•Ÿå‹•
        function startGame() {
            if (typeof THREE === 'undefined') {
                console.error('Three.js æœªè¼‰å…¥');
                document.getElementById('loading').innerHTML = 'âŒ Three.js è¼‰å…¥å¤±æ•—';
                return;
            }
            
            console.log('âœ… Three.js è¼‰å…¥æˆåŠŸ');
            
            setTimeout(() => {
                try {
                    initGame();
                } catch (error) {
                    console.error('âŒ éŠæˆ²åˆå§‹åŒ–éŒ¯èª¤:', error);
                    document.getElementById('loading').innerHTML = `âŒ è¼‰å…¥å¤±æ•—<br><small>${error.message}</small>`;
                }
            }, 100);
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œå•Ÿå‹•éŠæˆ²
        window.addEventListener('load', startGame);
        
        if (document.readyState === 'complete') {
            startGame();
        }
    </script>
</body>
</html>
