// éŠæˆ²ä¸»å¾ªç’°
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            handleMovement();
            updateChunkLoading(); // æ–°å¢ï¼šå‹•æ…‹å€å¡ŠåŠ è¼‰
            updateTargetBlock();
            updateCamera();
            updateDayNight();
            updateUI();
            
            gameState.renderer.render(gameState.scene, gameState.camera);
        }

        function updateChunkLoading() {
            const playerPos = gameState.camera.position;
            const currentChunkX = Math.floor(playerPos.x / gameState.chunkSize);
            const currentChunkZ = Math.floor(playerPos.z / gameState.chunkSize);
            
            // åªæœ‰ç•¶ç©å®¶ç§»å‹•åˆ°æ–°å€å¡Šæ™‚æ‰æ›´æ–°
            if (gameState.lastChunkUpdate.x !== currentChunkX || 
                gameState.lastChunkUpdate.z !== currentChunkZ) {
                
                updateChunksAroundPlayer(currentChunkX, currentChunkZ);
                gameState.lastChunkUpdate.x = currentChunkX;
                gameState.lastChunkUpdate.z = currentChunkZ;
            }
        }<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft é¢¨æ ¼åœ°åœ–ç³»çµ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            pointer-events: auto;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        .toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 15px;
            border: 3px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .tool-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #666;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(50, 50, 50, 0.8);
            cursor: pointer;
            font-size: 20px;
            color: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .tool-slot:hover {
            background: rgba(100, 100, 100, 0.8);
            transform: translateY(-2px);
        }

        .tool-slot.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.4);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }

        .tool-count {
            font-size: 10px;
            position: absolute;
            bottom: 2px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            text-align: right;
            font-size: 12px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
        }

        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            min-width: 200px;
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .block-info {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            font-size: 14px;
            display: none;
        }

        .mode-toggle {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .mode-toggle:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .height-indicator {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #4CAF50;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="loading" id="loading">ğŸ® è¼‰å…¥ Minecraft ä¸–ç•Œ...</div>
        <div class="crosshair"></div>
        
        <div id="ui" style="display: none;">
            <div class="info-panel panel">
                <h3>ğŸŒ ä¸–ç•Œè³‡è¨Š</h3>
                <div>åº§æ¨™: <span id="coordinates">0, 0, 0</span></div>
                <div>æ–¹å¡Š: <span id="blockCount">0</span> å€‹</div>
                <div>ç”Ÿç‰©ç¾¤è½: <span id="biome">å¹³åŸ</span></div>
                <div>æ™‚é–“: <span id="timeDisplay">ç™½å¤©</span></div>
            </div>

            <div class="mode-toggle" id="modeToggle" onclick="toggleMode()">
                ğŸ”¨ å»ºé€ æ¨¡å¼
            </div>

            <div class="controls">
                <div><strong>ğŸ® æ“ä½œèªªæ˜</strong></div>
                <div>WASD - ç§»å‹•</div>
                <div>ç©ºç™½éµ - è·³èº/é£›è¡Œä¸Šå‡</div>
                <div>Shift - ä¸‹é™(é£›è¡Œæ¨¡å¼)</div>
                <div>æ»‘é¼ å·¦éµ - ç ´å£æ–¹å¡Š</div>
                <div>æ»‘é¼ å³éµ - æ”¾ç½®æ–¹å¡Š</div>
                <div>æ»‘é¼ æ»¾è¼ª - åˆ‡æ›å·¥å…·</div>
                <div>1-9 - é¸æ“‡å·¥å…·</div>
                <div>F - åˆ‡æ›é£›è¡Œæ¨¡å¼</div>
                <div>R - é‡æ–°ç”Ÿæˆä¸–ç•Œ</div>
                <div>G - ç”Ÿæˆçµæ§‹</div>
            </div>

            <div class="height-indicator">
                <div>é«˜åº¦: <span id="heightDisplay">0</span></div>
                <div>æ¨¡å¼: <span id="modeDisplay">ç”Ÿå­˜</span></div>
            </div>
        </div>

        <div class="toolbar">
            <div class="tool-slot selected" data-slot="0" title="è‰æ–¹å¡Š">ğŸŸ©<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="1" title="æ³¥åœŸ">ğŸŸ«<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="2" title="çŸ³é ­">â¬œ<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="3" title="æœ¨é ­">ğŸŸ¤<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="4" title="æ¨¹è‘‰">ğŸŸ¢<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="5" title="æ²™å­">ğŸŸ¨<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="6" title="æ°´">ğŸ’§<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="7" title="å²©æ¼¿">ğŸ”¥<div class="tool-count">âˆ</div></div>
            <div class="tool-slot" data-slot="8" title="ç»ç’ƒ">ğŸ’<div class="tool-count">âˆ</div></div>
        </div>

        <div class="block-info" id="blockInfo">
            ç„æº–æ–¹å¡Š: è‰æ–¹å¡Š
        </div>
    </div>

    <script>
        // éŠæˆ²ç‹€æ…‹
        const gameState = {
            scene: null,
            camera: null,
            renderer: null,
            player: null,
            world: new Map(), // ä½¿ç”¨ Map ä¾†å­˜å„²æ–¹å¡Šä½ç½®
            chunks: new Map(), // å€å¡Šç³»çµ± - å­˜å„²å·²ç”Ÿæˆçš„å€å¡Šæ•¸æ“š
            loadedChunks: new Set(), // ç•¶å‰å·²åŠ è¼‰åˆ°å ´æ™¯ä¸­çš„å€å¡Š
            selectedTool: 0,
            isFlying: false,
            isSurvival: true,
            chunkSize: 16, // æ¯å€‹å€å¡Š16x16æ–¹å¡Š
            renderDistance: 3, // æ¸›å°æ¸²æŸ“è·é›¢åˆ°3å€‹å€å¡Š
            maxHeight: 50, // é™ä½æœ€å¤§é«˜åº¦
            seaLevel: 30, // é™ä½æµ·å¹³é¢
            keys: {},
            mouse: { x: 0, y: 0, locked: false },
            cameraDistance: 0, // ç¬¬ä¸€äººç¨±è¦–è§’
            cameraAngleX: 0,
            cameraAngleY: 0,
            velocity: { x: 0, y: 0, z: 0 },
            onGround: false,
            dayTime: 0,
            targetBlock: null,
            highlightMesh: null,
            lastChunkUpdate: { x: null, z: null },
            maxLoadedBlocks: 5000 // æ¸›å°‘æœ€å¤§æ–¹å¡Šæ•¸
        };

        // æ–¹å¡Šé¡å‹å®šç¾©
        const blockTypes = {
            GRASS: { 
                color: 0x90EE90, 
                name: 'grass', 
                emoji: 'ğŸŸ©',
                hardness: 1,
                transparent: false
            },
            DIRT: { 
                color: 0x8B4513, 
                name: 'dirt', 
                emoji: 'ğŸŸ«',
                hardness: 1,
                transparent: false
            },
            STONE: { 
                color: 0x808080, 
                name: 'stone', 
                emoji: 'â¬œ',
                hardness: 3,
                transparent: false
            },
            WOOD: { 
                color: 0xA0522D, 
                name: 'wood', 
                emoji: 'ğŸŸ¤',
                hardness: 2,
                transparent: false
            },
            LEAVES: { 
                color: 0x228B22, 
                name: 'leaves', 
                emoji: 'ğŸŸ¢',
                hardness: 0.5,
                transparent: true
            },
            SAND: { 
                color: 0xF4E4BC, 
                name: 'sand', 
                emoji: 'ğŸŸ¨',
                hardness: 0.8,
                transparent: false
            },
            WATER: { 
                color: 0x4169E1, 
                name: 'water', 
                emoji: 'ğŸ’§',
                hardness: 0,
                transparent: true
            },
            LAVA: { 
                color: 0xFF4500, 
                name: 'lava', 
                emoji: 'ğŸ”¥',
                hardness: 0,
                transparent: true
            },
            GLASS: { 
                color: 0xE6F3FF, 
                name: 'glass', 
                emoji: 'ğŸ’',
                hardness: 1,
                transparent: true
            }
        };

        const toolOrder = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'water', 'lava', 'glass'];

        // å™ªè²å‡½æ•¸ï¼ˆç°¡åŒ–ç‰ˆæŸæ—å™ªè²ï¼‰
        class NoiseGenerator {
            constructor(seed = 12345) {
                this.seed = seed;
            }

            noise(x, z, scale = 0.1) {
                x *= scale;
                z *= scale;
                
                const X = Math.floor(x) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                z -= Math.floor(z);
                
                const u = this.fade(x);
                const v = this.fade(z);
                
                const a = this.p[X] + Z;
                const b = this.p[X + 1] + Z;
                
                return this.lerp(v, 
                    this.lerp(u, this.grad(this.p[a], x, z), this.grad(this.p[b], x - 1, z)),
                    this.lerp(u, this.grad(this.p[a + 1], x, z - 1), this.grad(this.p[b + 1], x - 1, z - 1))
                );
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, z) {
                const h = hash & 15;
                const u = h < 8 ? x : z;
                const v = h < 4 ? z : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            get p() {
                if (!this._p) {
                    this._p = [];
                    for (let i = 0; i < 256; i++) {
                        this._p[i] = Math.floor(Math.random() * 256);
                    }
                    this._p = this._p.concat(this._p);
                }
                return this._p;
            }
        }

        const noiseGen = new NoiseGenerator();

        // ç­‰å¾… Three.js è¼‰å…¥
        function startGame() {
            if (typeof THREE === 'undefined') {
                setTimeout(startGame, 100);
                return;
            }
            
            setTimeout(() => {
                try {
                    initGame();
                } catch (error) {
                    console.error('éŠæˆ²åˆå§‹åŒ–å¤±æ•—:', error);
                    document.getElementById('loading').textContent = 'âŒ è¼‰å…¥å¤±æ•—: ' + error.message;
                }
            }, 100);
        }

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            console.log('ğŸ® åˆå§‹åŒ– Minecraft ä¸–ç•Œ...');
            
            const canvas = document.getElementById('gameCanvas');
            
            // Three.js è¨­ç½®
            gameState.scene = new THREE.Scene();
            gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            gameState.renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true 
            });
            
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            gameState.renderer.setClearColor(0x87CEEB, 1);
            gameState.renderer.shadowMap.enabled = true;
            gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // è¨­ç½®å…‰æº
            setupLighting();
            
            // ç”Ÿæˆä¸–ç•Œ
            generateWorld();
            
            // å‰µå»ºç©å®¶
            createPlayer();
            
            // å‰µå»ºæ–¹å¡Šé«˜äº®
            createBlockHighlight();
            
            // è¨­ç½®æ§åˆ¶
            setupControls();
            
            // å•Ÿç”¨æŒ‡é‡é–å®š
            setupPointerLock();
            
            // éš±è—è¼‰å…¥ç•«é¢
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            // é–‹å§‹éŠæˆ²å¾ªç’°
            gameLoop();
            
            console.log('âœ… Minecraft ä¸–ç•Œè¼‰å…¥å®Œæˆï¼');
        }

        function setupLighting() {
            // ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            gameState.scene.add(ambientLight);

            // å¤ªé™½å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            gameState.scene.add(directionalLight);
        }

        function generateWorld() {
            console.log('ğŸŒ åˆå§‹åŒ–å€å¡Šç³»çµ±...');
            
            // è¨­ç½®ç©å®¶åˆå§‹ä½ç½®åˆ°ä¸€å€‹å®‰å…¨çš„åœ°é¢ä½ç½®
            gameState.camera.position.set(0, 40, 0);
            
            // åˆå§‹ç”Ÿæˆç©å®¶å‘¨åœçš„å€å¡Š
            const playerChunkX = Math.floor(gameState.camera.position.x / gameState.chunkSize);
            const playerChunkZ = Math.floor(gameState.camera.position.z / gameState.chunkSize);
            
            // ç«‹å³ç”Ÿæˆä¸­å¿ƒå€å¡Š
            for (let x = playerChunkX - 2; x <= playerChunkX + 2; x++) {
                for (let z = playerChunkZ - 2; z <= playerChunkZ + 2; z++) {
                    generateChunkData(x, z);
                    loadChunk(x, z);
                }
            }
            
            // è¨­ç½®ç©å®¶åˆ°åœ°é¢
            setTimeout(() => {
                const groundY = getTopBlockY(0, 0);
                if (groundY > 0) {
                    gameState.camera.position.y = groundY + 2;
                }
            }, 100);
            
            console.log(`âœ… åˆå§‹å€å¡Šè¼‰å…¥å®Œæˆï¼Œå…±ç”Ÿæˆ ${gameState.world.size} å€‹æ–¹å¡Š`);
        }

        // å€å¡Šç®¡ç†ç³»çµ±
        function updateChunksAroundPlayer(playerChunkX, playerChunkZ) {
            const renderDistance = gameState.renderDistance;
            const requiredChunks = new Set();
            
            // è¨ˆç®—éœ€è¦çš„å€å¡Š
            for (let x = playerChunkX - renderDistance; x <= playerChunkX + renderDistance; x++) {
                for (let z = playerChunkZ - renderDistance; z <= playerChunkZ + renderDistance; z++) {
                    const distance = Math.sqrt((x - playerChunkX) ** 2 + (z - playerChunkZ) ** 2);
                    if (distance <= renderDistance) {
                        requiredChunks.add(`${x},${z}`);
                    }
                }
            }
            
            // å¸è¼‰é é›¢çš„å€å¡Š
            const toUnload = [];
            for (const chunkKey of gameState.loadedChunks) {
                if (!requiredChunks.has(chunkKey)) {
                    toUnload.push(chunkKey);
                }
            }
            
            // æ‰¹é‡å¸è¼‰ä»¥é¿å…æ€§èƒ½å•é¡Œ
            let unloadCount = 0;
            for (const chunkKey of toUnload) {
                if (unloadCount >= 2) break; // æ¯å¹€æœ€å¤šå¸è¼‰2å€‹å€å¡Š
                unloadChunk(chunkKey);
                unloadCount++;
            }
            
            // åŠ è¼‰æ–°å€å¡Š
            let loadCount = 0;
            for (const chunkKey of requiredChunks) {
                if (!gameState.loadedChunks.has(chunkKey)) {
                    if (loadCount >= 1) break; // æ¯å¹€æœ€å¤šåŠ è¼‰1å€‹å€å¡Š
                    const [x, z] = chunkKey.split(',').map(Number);
                    loadChunk(x, z);
                    loadCount++;
                }
            }
            
            // æª¢æŸ¥ç¸½æ–¹å¡Šæ•¸é‡
            if (gameState.world.size > gameState.maxLoadedBlocks) {
                console.warn('âš ï¸ æ–¹å¡Šæ•¸é‡éå¤šï¼Œå¼·åˆ¶æ¸…ç†é è·é›¢å€å¡Š');
                forceUnloadDistantChunks(playerChunkX, playerChunkZ);
            }
        }

        function loadChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“ç”Ÿæˆéé€™å€‹å€å¡Šçš„æ•¸æ“š
            if (!gameState.chunks.has(chunkKey)) {
                generateChunkData(chunkX, chunkZ);
            }
            
            // åŠ è¼‰å€å¡Šåˆ°å ´æ™¯ä¸­
            const chunkData = gameState.chunks.get(chunkKey);
            if (chunkData) {
                for (const blockData of chunkData.blocks) {
                    createBlockMesh(blockData.x, blockData.y, blockData.z, blockData.type);
                }
                gameState.loadedChunks.add(chunkKey);
                console.log(`ğŸ“¦ åŠ è¼‰å€å¡Š ${chunkKey}ï¼ŒåŒ…å« ${chunkData.blocks.length} å€‹æ–¹å¡Š`);
            }
        }

        function unloadChunk(chunkKey) {
            const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
            const startX = chunkX * gameState.chunkSize;
            const startZ = chunkZ * gameState.chunkSize;
            const endX = startX + gameState.chunkSize;
            const endZ = startZ + gameState.chunkSize;
            
            // ç§»é™¤è©²å€å¡Šçš„æ‰€æœ‰æ–¹å¡Šmesh
            const blocksToRemove = [];
            for (const [blockKey, block] of gameState.world) {
                if (block.x >= startX && block.x < endX && 
                    block.z >= startZ && block.z < endZ) {
                    blocksToRemove.push(blockKey);
                    gameState.scene.remove(block.mesh);
                    
                    // é‡‹æ”¾å¹¾ä½•é«”å’Œæè³ª
                    if (block.mesh.geometry) block.mesh.geometry.dispose();
                    if (block.mesh.material) block.mesh.material.dispose();
                }
            }
            
            // å¾worldä¸­ç§»é™¤
            for (const blockKey of blocksToRemove) {
                gameState.world.delete(blockKey);
            }
            
            gameState.loadedChunks.delete(chunkKey);
            console.log(`ğŸ—‘ï¸ å¸è¼‰å€å¡Š ${chunkKey}ï¼Œç§»é™¤ ${blocksToRemove.length} å€‹æ–¹å¡Š`);
        }

        function generateChunkData(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            const chunkData = { blocks: [] };
            
            const startX = chunkX * gameState.chunkSize;
            const startZ = chunkZ * gameState.chunkSize;
            
            for (let x = startX; x < startX + gameState.chunkSize; x++) {
                for (let z = startZ; z < startZ + gameState.chunkSize; z++) {
                    generateColumnData(x, z, chunkData);
                }
            }
            
            // åœ¨è©²å€å¡Šç”Ÿæˆä¸€äº›æ¨¹æœ¨
            generateChunkStructures(chunkX, chunkZ, chunkData);
            
            gameState.chunks.set(chunkKey, chunkData);
        }

        function generateColumnData(x, z, chunkData) {
            // ä½¿ç”¨å™ªè²ç”Ÿæˆé«˜åº¦ - èª¿æ•´åƒæ•¸è®“åœ°å½¢æ›´æ˜é¡¯
            const heightNoise = noiseGen.noise(x, z, 0.03) * 8 + 32; // é™ä½é«˜åº¦è®ŠåŒ–
            const caveNoise = noiseGen.noise(x, z, 0.1);
            
            const height = Math.floor(heightNoise);
            const maxHeight = Math.min(height, 45); // é™ä½æœ€å¤§é«˜åº¦
            
            for (let y = 0; y <= maxHeight; y++) {
                let blockType;
                
                // ç°¡åŒ–æ´ç©´ç”Ÿæˆ - æ¸›å°‘æ´ç©´
                if (y < maxHeight - 8 && Math.abs(caveNoise) < 0.03) {
                    continue; // å‰µå»ºæ´ç©´
                }
                
                if (y === maxHeight) {
                    // è¡¨é¢æ–¹å¡Š
                    if (y > gameState.seaLevel + 5) {
                        blockType = blockTypes.GRASS; // æ›´å¤šè‰åœ°
                    } else {
                        blockType = blockTypes.SAND; // æµ·ç˜
                    }
                } else if (y > maxHeight - 2) {
                    // è¡¨å±¤åœŸå£¤
                    blockType = blockTypes.DIRT;
                } else if (y < 5) {
                    // åŸºå²©å±¤
                    blockType = blockTypes.STONE;
                } else {
                    // åœ°ä¸‹ - å¢åŠ æ–¹å¡Šå¯†åº¦
                    if (Math.random() < 0.9) { // 90%æ¦‚ç‡ç”Ÿæˆåœ°ä¸‹æ–¹å¡Š
                        blockType = blockTypes.STONE;
                    } else {
                        continue;
                    }
                }
                
                if (blockType) {
                    chunkData.blocks.push({
                        x: x, y: y, z: z,
                        type: blockType
                    });
                }
            }
            
            // ç°¡åŒ–æ°´çš„ç”Ÿæˆ
            if (height < gameState.seaLevel) {
                for (let y = height + 1; y <= gameState.seaLevel; y++) {
                    chunkData.blocks.push({
                        x: x, y: y, z: z,
                        type: blockTypes.WATER
                    });
                }
            }
        }

        function generateChunkStructures(chunkX, chunkZ, chunkData) {
            // æ¯å€‹å€å¡Šéš¨æ©Ÿç”Ÿæˆ1-2æ£µæ¨¹
            const treeCount = Math.floor(Math.random() * 2) + 1;
            const startX = chunkX * gameState.chunkSize;
            const startZ = chunkZ * gameState.chunkSize;
            
            for (let i = 0; i < treeCount; i++) {
                const x = startX + Math.floor(Math.random() * gameState.chunkSize);
                const z = startZ + Math.floor(Math.random() * gameState.chunkSize);
                
                // æ‰¾åˆ°è©²ä½ç½®çš„åœ°é¢é«˜åº¦
                let groundY = 0;
                for (const block of chunkData.blocks) {
                    if (block.x === x && block.z === z && block.y > groundY) {
                        if (block.type.name === 'grass' || block.type.name === 'dirt') {
                            groundY = block.y;
                        }
                    }
                }
                
                if (groundY > gameState.seaLevel) {
                    generateTreeData(x, groundY + 1, z, chunkData);
                }
            }
        }

        function generateTreeData(x, y, z, chunkData) {
            const height = 3 + Math.floor(Math.random() * 2); // æ¨¹é«˜3-4
            
            // æ¨¹å¹¹
            for (let i = 0; i < height; i++) {
                chunkData.blocks.push({
                    x: x, y: y + i, z: z,
                    type: blockTypes.WOOD
                });
            }
            
            // æ¨¹è‘‰ - ç°¡åŒ–æ¨¹è‘‰ç”Ÿæˆ
            const leafY = y + height - 1;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dz === 0) continue; // ä¸è¦†è“‹æ¨¹å¹¹é ‚éƒ¨
                    
                    // æ¨¹è‘‰å±¤
                    chunkData.blocks.push({
                        x: x + dx, y: leafY, z: z + dz,
                        type: blockTypes.LEAVES
                    });
                    
                    // é ‚å±¤æ¨¹è‘‰
                    if (Math.abs(dx) + Math.abs(dz) <= 1) {
                        chunkData.blocks.push({
                            x: x + dx, y: leafY + 1, z: z + dz,
                            type: blockTypes.LEAVES
                        });
                    }
                }
            }
        }

        function forceUnloadDistantChunks(playerChunkX, playerChunkZ) {
            const chunksToUnload = [];
            
            for (const chunkKey of gameState.loadedChunks) {
                const [x, z] = chunkKey.split(',').map(Number);
                const distance = Math.sqrt((x - playerChunkX) ** 2 + (z - playerChunkZ) ** 2);
                
                if (distance > gameState.renderDistance + 1) {
                    chunksToUnload.push(chunkKey);
                }
            }
            
            // å¼·åˆ¶å¸è¼‰æœ€é çš„å€å¡Š
            chunksToUnload.sort((a, b) => {
                const [ax, az] = a.split(',').map(Number);
                const [bx, bz] = b.split(',').map(Number);
                const distA = Math.sqrt((ax - playerChunkX) ** 2 + (az - playerChunkZ) ** 2);
                const distB = Math.sqrt((bx - playerChunkX) ** 2 + (bz - playerChunkZ) ** 2);
                return distB - distA;
            });
            
            for (let i = 0; i < Math.min(3, chunksToUnload.length); i++) {
                unloadChunk(chunksToUnload[i]);
            }
        }

        function setBlock(x, y, z, blockType) {
            const key = `${x},${y},${z}`;
            
            // ç§»é™¤èˆŠæ–¹å¡Š
            if (gameState.world.has(key)) {
                const oldBlock = gameState.world.get(key);
                gameState.scene.remove(oldBlock.mesh);
                if (oldBlock.mesh.geometry) oldBlock.mesh.geometry.dispose();
                if (oldBlock.mesh.material) oldBlock.mesh.material.dispose();
            }
            
            // å‰µå»ºæ–°æ–¹å¡Š
            const block = createBlockMesh(x, y, z, blockType);
            return block;
        }

        function createBlockMesh(x, y, z, blockType) {
            const key = `${x},${y},${z}`;
            
            // ä½¿ç”¨å…±äº«çš„å¹¾ä½•é«”ä»¥ç¯€çœå…§å­˜
            const geometry = getSharedGeometry();
            let material = getSharedMaterial(blockType);
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const block = {
                mesh: mesh,
                type: blockType.name,
                x: x, y: y, z: z
            };
            
            gameState.scene.add(mesh);
            gameState.world.set(key, block);
            
            return block;
        }

        // å…±äº«è³‡æºç®¡ç†
        let sharedGeometry = null;
        const sharedMaterials = new Map();

        function getSharedGeometry() {
            if (!sharedGeometry) {
                sharedGeometry = new THREE.BoxGeometry(1, 1, 1);
            }
            return sharedGeometry;
        }

        function getSharedMaterial(blockType) {
            const key = blockType.name;
            
            if (!sharedMaterials.has(key)) {
                let material;
                if (blockType.transparent) {
                    material = new THREE.MeshLambertMaterial({ 
                        color: blockType.color,
                        transparent: true,
                        opacity: blockType.name === 'water' ? 0.7 : 0.9
                    });
                } else {
                    material = new THREE.MeshLambertMaterial({ color: blockType.color });
                }
                sharedMaterials.set(key, material);
            }
            
            return sharedMaterials.get(key);
        }

        function getBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = gameState.world.get(key);
            return block ? blockTypes[block.type.toUpperCase()] : null;
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = gameState.world.get(key);
            
            if (block) {
                gameState.scene.remove(block.mesh);
                // ä¸éœ€è¦disposeå…±äº«çš„geometryå’Œmaterial
                gameState.world.delete(key);
                
                // åŒæ™‚å¾å€å¡Šæ•¸æ“šä¸­ç§»é™¤
                const chunkX = Math.floor(x / gameState.chunkSize);
                const chunkZ = Math.floor(z / gameState.chunkSize);
                const chunkKey = `${chunkX},${chunkZ}`;
                const chunkData = gameState.chunks.get(chunkKey);
                
                if (chunkData) {
                    chunkData.blocks = chunkData.blocks.filter(b => 
                        !(b.x === x && b.y === y && b.z === z)
                    );
                }
                
                return true;
            }
            return false;
        }

        function getTopBlockY(x, z) {
            let maxHeight = 0;
            
            // é¦–å…ˆæª¢æŸ¥å·²åŠ è¼‰çš„æ–¹å¡Š
            for (const [key, block] of gameState.world) {
                if (Math.abs(block.x - x) < 1 && Math.abs(block.z - z) < 1) {
                    maxHeight = Math.max(maxHeight, block.y);
                }
            }
            
            // å¦‚æœæ²’æœ‰æ‰¾åˆ°ï¼Œæª¢æŸ¥å€å¡Šæ•¸æ“š
            if (maxHeight === 0) {
                const chunkX = Math.floor(x / gameState.chunkSize);
                const chunkZ = Math.floor(z / gameState.chunkSize);
                const chunkKey = `${chunkX},${chunkZ}`;
                const chunkData = gameState.chunks.get(chunkKey);
                
                if (chunkData) {
                    for (const block of chunkData.blocks) {
                        if (block.x === x && block.z === z) {
                            maxHeight = Math.max(maxHeight, block.y);
                        }
                    }
                }
            }
            
            return maxHeight;
        }

        function createPlayer() {
            // è¨­ç½®ç©å®¶åˆå§‹ä½ç½®åˆ°åœ°é¢ä¸Šæ–¹
            gameState.camera.position.set(0, 35, 0);
            gameState.velocity = { x: 0, y: 0, z: 0 };
            
            console.log('ğŸ‘¤ ç©å®¶å‰µå»ºå®Œæˆï¼Œä½ç½®:', gameState.camera.position);
        }

        function createBlockHighlight() {
            const geometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            
            gameState.highlightMesh = new THREE.Mesh(geometry, material);
            gameState.highlightMesh.visible = false;
            gameState.scene.add(gameState.highlightMesh);
        }

        function setupPointerLock() {
            const canvas = document.getElementById('gameCanvas');
            
            canvas.addEventListener('click', () => {
                if (!gameState.mouse.locked) {
                    canvas.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                gameState.mouse.locked = document.pointerLockElement === canvas;
            });
        }

        function setupControls() {
            // éµç›¤äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                
                // æ•¸å­—éµé¸æ“‡å·¥å…·
                if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                    const slot = parseInt(e.code.replace('Digit', '')) - 1;
                    if (slot < toolOrder.length) {
                        selectTool(slot);
                    }
                }
                
                // åŠŸèƒ½éµ
                switch (e.code) {
                    case 'KeyF':
                        toggleFlying();
                        break;
                    case 'KeyR':
                        if (confirm('é‡æ–°ç”Ÿæˆä¸–ç•Œï¼Ÿé€™å°‡æ¸…é™¤æ‰€æœ‰æ›´æ”¹ã€‚')) {
                            regenerateWorld();
                        }
                        break;
                    case 'KeyG':
                        generateRandomStructure();
                        break;
                }
                
                e.preventDefault();
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            // æ»‘é¼ äº‹ä»¶
            document.addEventListener('mousedown', (e) => {
                if (!gameState.mouse.locked) return;
                
                if (e.button === 0) { // å·¦éµ - ç ´å£
                    handleBlockBreak();
                } else if (e.button === 2) { // å³éµ - æ”¾ç½®
                    handleBlockPlace();
                }
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!gameState.mouse.locked) return;
                
                const sensitivity = 0.002;
                gameState.cameraAngleX -= e.movementX * sensitivity;
                gameState.cameraAngleY -= e.movementY * sensitivity;
                gameState.cameraAngleY = Math.max(-Math.PI/2, Math.min(Math.PI/2, gameState.cameraAngleY));
            });
            
            document.addEventListener('wheel', (e) => {
                if (!gameState.mouse.locked) return;
                
                const delta = e.deltaY > 0 ? 1 : -1;
                gameState.selectedTool = (gameState.selectedTool + delta + toolOrder.length) % toolOrder.length;
                selectTool(gameState.selectedTool);
                
                e.preventDefault();
            });
            
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // é»æ“Šå·¥å…·æ¬„
            document.querySelectorAll('.tool-slot').forEach((slot, index) => {
                slot.addEventListener('click', () => selectTool(index));
            });
            
            // è¦–çª—å¤§å°èª¿æ•´
            window.addEventListener('resize', () => {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function handleBlockBreak() {
            const target = getTargetBlock();
            if (target) {
                removeBlock(target.x, target.y, target.z);
                updateUI();
            }
        }

        function handleBlockPlace() {
            const target = getTargetBlock();
            if (target && target.face) {
                const pos = {
                    x: target.x + target.face.normal.x,
                    y: target.y + target.face.normal.y,
                    z: target.z + target.face.normal.z
                };
                
                // æª¢æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨æˆ–åœ¨ç©å®¶ä½ç½®
                const playerPos = gameState.camera.position;
                const blockCenter = { x: pos.x + 0.5, y: pos.y + 0.5, z: pos.z + 0.5 };
                const distance = Math.sqrt(
                    Math.pow(playerPos.x - blockCenter.x, 2) +
                    Math.pow(playerPos.y - blockCenter.y, 2) +
                    Math.pow(playerPos.z - blockCenter.z, 2)
                );
                
                if (distance > 1.2 && !getBlock(pos.x, pos.y, pos.z)) {
                    const selectedBlockType = Object.values(blockTypes).find(bt => 
                        bt.name === toolOrder[gameState.selectedTool]
                    );
                    
                    if (selectedBlockType) {
                        setBlock(pos.x, pos.y, pos.z, selectedBlockType);
                        updateUI();
                    }
                }
            }
        }

        function getTargetBlock() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), gameState.camera);
            
            const blocks = Array.from(gameState.world.values()).map(block => block.mesh);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0) {
                const intersection = intersects[0];
                const block = gameState.world.get(
                    `${intersection.object.position.x},${intersection.object.position.y},${intersection.object.position.z}`
                );
                
                if (block) {
                    return {
                        x: block.x,
                        y: block.y,
                        z: block.z,
                        face: intersection.face,
                        distance: intersection.distance
                    };
                }
            }
            
            return null;
        }

        function selectTool(index) {
            if (index >= 0 && index < toolOrder.length) {
                gameState.selectedTool = index;
                
                // æ›´æ–°UI
                document.querySelectorAll('.tool-slot').forEach((slot, i) => {
                    slot.classList.toggle('selected', i === index);
                });
                
                // é¡¯ç¤ºå·¥å…·ä¿¡æ¯
                const blockType = Object.values(blockTypes).find(bt => bt.name === toolOrder[index]);
                showBlockInfo(`é¸ä¸­: ${blockType.emoji} ${blockType.name}`);
            }
        }

        function toggleFlying() {
            gameState.isFlying = !gameState.isFlying;
            gameState.velocity.y = 0;
            console.log('âœˆï¸ é£›è¡Œæ¨¡å¼:', gameState.isFlying ? 'é–‹å•Ÿ' : 'é—œé–‰');
            updateUI();
        }

        function toggleMode() {
            gameState.isSurvival = !gameState.isSurvival;
            const modeToggle = document.getElementById('modeToggle');
            modeToggle.textContent = gameState.isSurvival ? 'ğŸ”¨ å»ºé€ æ¨¡å¼' : 'âš”ï¸ ç”Ÿå­˜æ¨¡å¼';
            console.log('ğŸ® åˆ‡æ›åˆ°', gameState.isSurvival ? 'ç”Ÿå­˜æ¨¡å¼' : 'å‰µé€ æ¨¡å¼');
            updateUI();
        }

        function regenerateWorld() {
            // æ¸…é™¤ç¾æœ‰ä¸–ç•Œ
            gameState.world.forEach(block => {
                gameState.scene.remove(block.mesh);
            });
            gameState.world.clear();
            gameState.chunks.clear();
            gameState.loadedChunks.clear();
            
            // é‡æ–°ç”Ÿæˆ
            const playerChunkX = Math.floor(gameState.camera.position.x / gameState.chunkSize);
            const playerChunkZ = Math.floor(gameState.camera.position.z / gameState.chunkSize);
            updateChunksAroundPlayer(playerChunkX, playerChunkZ);
            
            updateUI();
            console.log('ğŸŒ ä¸–ç•Œå·²é‡æ–°ç”Ÿæˆ');
        }

        function generateRandomStructure() {
            const playerPos = gameState.camera.position;
            const x = Math.floor(playerPos.x + (Math.random() - 0.5) * 20);
            const z = Math.floor(playerPos.z + (Math.random() - 0.5) * 20);
            const y = getTopBlockY(x, z) + 1;
            
            const structures = [
                () => generateTower(x, y, z),
                () => generatePyramid(x, y, z),
                () => generateBridge(x, y, z),
                () => generateHouse(x, y, z)
            ];
            
            const randomStructure = structures[Math.floor(Math.random() * structures.length)];
            randomStructure();
            
            console.log('ğŸ—ï¸ åœ¨', x, y, z, 'ç”Ÿæˆäº†éš¨æ©Ÿçµæ§‹');
        }

        function generateTower(x, y, z) {
            const height = 8 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < height; i++) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dz === 0 && i < height - 1) continue; // ç©ºå¿ƒ
                        setBlock(x + dx, y + i, z + dz, blockTypes.STONE);
                    }
                }
            }
        }

        function generatePyramid(x, y, z) {
            const size = 4;
            
            for (let level = 0; level < size; level++) {
                const currentSize = size - level;
                for (let dx = -currentSize; dx <= currentSize; dx++) {
                    for (let dz = -currentSize; dz <= currentSize; dz++) {
                        if (Math.abs(dx) === currentSize || Math.abs(dz) === currentSize) {
                            setBlock(x + dx, y + level, z + dz, blockTypes.SAND);
                        }
                    }
                }
            }
        }

        function generateBridge(x, y, z) {
            const length = 10;
            
            for (let i = 0; i < length; i++) {
                setBlock(x + i, y, z, blockTypes.WOOD);
                setBlock(x + i, y, z + 1, blockTypes.WOOD);
                
                // æ¬„æ†
                if (i % 2 === 0) {
                    setBlock(x + i, y + 1, z - 1, blockTypes.WOOD);
                    setBlock(x + i, y + 1, z + 2, blockTypes.WOOD);
                }
            }
        }

        function generateHouse(x, y, z) {
            const width = 5, height = 4, depth = 5;
            
            // åœ°åŸº
            for (let dx = 0; dx < width; dx++) {
                for (let dz = 0; dz < depth; dz++) {
                    setBlock(x + dx, y - 1, z + dz, blockTypes.STONE);
                }
            }
            
            // ç‰†å£
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    for (let dz = 0; dz < depth; dz++) {
                        if (dx === 0 || dx === width - 1 || dz === 0 || dz === depth - 1) {
                            if (!(dx === 2 && dz === 0 && dy < 2)) { // é–€
                                setBlock(x + dx, y + dy, z + dz, blockTypes.WOOD);
                            }
                        }
                    }
                }
            }
            
            // å±‹é ‚
            for (let dx = -1; dx <= width; dx++) {
                for (let dz = -1; dz <= depth; dz++) {
                    setBlock(x + dx, y + height, z + dz, blockTypes.WOOD);
                }
            }
        }

        function showBlockInfo(text) {
            const blockInfo = document.getElementById('blockInfo');
            blockInfo.textContent = text;
            blockInfo.style.display = 'block';
            
            setTimeout(() => {
                blockInfo.style.display = 'none';
            }, 2000);
        }

        // éŠæˆ²ä¸»å¾ªç’°
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            handleMovement();
            updateChunkLoading(); // æ–°å¢ï¼šå‹•æ…‹å€å¡ŠåŠ è¼‰
            updateTargetBlock();
            updateCamera();
            updateDayNight();
            updateUI();
            
            gameState.renderer.render(gameState.scene, gameState.camera);
        }

        function updateChunkLoading() {
            const playerPos = gameState.camera.position;
            const currentChunkX = Math.floor(playerPos.x / gameState.chunkSize);
            const currentChunkZ = Math.floor(playerPos.z / gameState.chunkSize);
            
            // åªæœ‰ç•¶ç©å®¶ç§»å‹•åˆ°æ–°å€å¡Šæ™‚æ‰æ›´æ–°
            if (gameState.lastChunkUpdate.x !== currentChunkX || 
                gameState.lastChunkUpdate.z !== currentChunkZ) {
                
                updateChunksAroundPlayer(currentChunkX, currentChunkZ);
                gameState.lastChunkUpdate.x = currentChunkX;
                gameState.lastChunkUpdate.z = currentChunkZ;
            }
        }

        function handleMovement() {
            const moveSpeed = gameState.isFlying ? 0.3 : 0.1;
            const jumpForce = 0.2;
            
            // è¨ˆç®—ç§»å‹•æ–¹å‘ï¼ˆç›¸å°æ–¼ç›¸æ©Ÿï¼‰
            const forward = new THREE.Vector3();
            gameState.camera.getWorldDirection(forward);
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            right.normalize();
            
            if (!gameState.isFlying) {
                forward.y = 0;
                forward.normalize();
            }
            
            // ç§»å‹•è¼¸å…¥
            const movement = new THREE.Vector3();
            
            if (gameState.keys['KeyW']) {
                movement.add(forward.clone().multiplyScalar(moveSpeed));
            }
            if (gameState.keys['KeyS']) {
                movement.add(forward.clone().multiplyScalar(-moveSpeed));
            }
            if (gameState.keys['KeyA']) {
                movement.add(right.clone().multiplyScalar(-moveSpeed));
            }
            if (gameState.keys['KeyD']) {
                movement.add(right.clone().multiplyScalar(moveSpeed));
            }
            
            // å‚ç›´ç§»å‹•
            if (gameState.isFlying) {
                if (gameState.keys['Space']) {
                    movement.y += moveSpeed;
                }
                if (gameState.keys['ShiftLeft']) {
                    movement.y -= moveSpeed;
                }
            } else {
                // é‡åŠ›
                gameState.velocity.y -= 0.01;
                
                // è·³èº
                if (gameState.keys['Space'] && gameState.onGround) {
                    gameState.velocity.y = jumpForce;
                    gameState.onGround = false;
                }
                
                movement.y += gameState.velocity.y;
            }
            
            // æ‡‰ç”¨ç§»å‹•
            const newPosition = gameState.camera.position.clone().add(movement);
            
            // ç¢°æ’æª¢æ¸¬
            if (!gameState.isFlying) {
                // åœ°é¢æª¢æ¸¬ - å„ªåŒ–ç‰ˆæœ¬ï¼Œä¸éœ€è¦æƒææ‰€æœ‰æ–¹å¡Š
                const groundY = getTopBlockY(Math.floor(newPosition.x), Math.floor(newPosition.z)) + 1.8;
                
                if (newPosition.y <= groundY) {
                    newPosition.y = groundY;
                    gameState.velocity.y = 0;
                    gameState.onGround = true;
                } else {
                    gameState.onGround = false;
                }
                
                // ç°¡åŒ–çš„ç‰†å£ç¢°æ’æª¢æ¸¬
                const playerRadius = 0.3;
                const checkPositions = [
                    { x: newPosition.x + playerRadius, z: newPosition.z },
                    { x: newPosition.x - playerRadius, z: newPosition.z },
                    { x: newPosition.x, z: newPosition.z + playerRadius },
                    { x: newPosition.x, z: newPosition.z - playerRadius }
                ];
                
                let collision = false;
                for (const pos of checkPositions) {
                    const blockY = getTopBlockY(Math.floor(pos.x), Math.floor(pos.z));
                    if (blockY >= newPosition.y - 0.5) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    gameState.camera.position.copy(newPosition);
                } else {
                    // åªæ‡‰ç”¨Yè»¸ç§»å‹•
                    gameState.camera.position.y = newPosition.y;
                }
            } else {
                gameState.camera.position.copy(newPosition);
            }
            
            // é«˜åº¦é™åˆ¶
            gameState.camera.position.y = Math.max(1, Math.min(gameState.maxHeight + 20, gameState.camera.position.y));
        }

        function updateTargetBlock() {
            const target = getTargetBlock();
            
            if (target && target.distance < 5) {
                gameState.highlightMesh.position.set(target.x, target.y, target.z);
                gameState.highlightMesh.visible = true;
                gameState.targetBlock = target;
            } else {
                gameState.highlightMesh.visible = false;
                gameState.targetBlock = null;
            }
        }

        function updateCamera() {
            // ç¬¬ä¸€äººç¨±è¦–è§’æ—‹è½‰
            gameState.camera.rotation.order = 'YXZ';
            gameState.camera.rotation.y = gameState.cameraAngleX;
            gameState.camera.rotation.x = gameState.cameraAngleY;
        }

        function updateDayNight() {
            gameState.dayTime += 0.001;
            if (gameState.dayTime > 1) gameState.dayTime = 0;
            
            const isNight = gameState.dayTime > 0.5;
            const timePhase = isNight ? (gameState.dayTime - 0.5) * 2 : gameState.dayTime * 2;
            
            // èª¿æ•´å¤©ç©ºé¡è‰²
            if (isNight) {
                const nightColor = new THREE.Color(0x191970);
                gameState.renderer.setClearColor(nightColor);
            } else {
                const skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0xFFB347), // æ—¥å‡º/æ—¥è½
                    new THREE.Color(0x87CEEB), // æ­£åˆ
                    Math.abs(timePhase - 0.5) * 2
                );
                gameState.renderer.setClearColor(skyColor);
            }
            
            // èª¿æ•´å…‰ç…§
            const lights = gameState.scene.children.filter(child => 
                child.type === 'AmbientLight' || child.type === 'DirectionalLight'
            );
            
            const lightIntensity = isNight ? 0.3 : 0.8;
            lights.forEach(light => {
                if (light.type === 'AmbientLight') {
                    light.intensity = lightIntensity * 0.6;
                } else if (light.type === 'DirectionalLight') {
                    light.intensity = lightIntensity;
                }
            });
        }

        function updateUI() {
            const pos = gameState.camera.position;
            
            // æ›´æ–°åº§æ¨™
            document.getElementById('coordinates').textContent = 
                `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
            
            // æ›´æ–°æ–¹å¡Šæ•¸é‡å’Œå…§å­˜ä½¿ç”¨æƒ…æ³
            const chunkCount = gameState.loadedChunks.size;
            document.getElementById('blockCount').textContent = 
                `${gameState.world.size} (${chunkCount} å€å¡Š)`;
            
            // æ›´æ–°é«˜åº¦
            document.getElementById('heightDisplay').textContent = Math.floor(pos.y);
            
            // æ›´æ–°æ¨¡å¼
            document.getElementById('modeDisplay').textContent = 
                gameState.isFlying ? 'é£›è¡Œ' : (gameState.isSurvival ? 'ç”Ÿå­˜' : 'å‰µé€ ');
            
            // æ›´æ–°æ™‚é–“
            const isNight = gameState.dayTime > 0.5;
            document.getElementById('timeDisplay').textContent = isNight ? 'ğŸŒ™ å¤œæ™š' : 'â˜€ï¸ ç™½å¤©';
            
            // æ›´æ–°ç”Ÿç‰©ç¾¤è½
            const biome = pos.y > 40 ? 'å±±åœ°' : pos.y > 35 ? 'å¹³åŸ' : 'æµ·å²¸';
            document.getElementById('biome').textContent = biome;
            
            // æ€§èƒ½è­¦å‘Š
            if (gameState.world.size > gameState.maxLoadedBlocks * 0.8) {
                console.warn(`âš ï¸ æ–¹å¡Šæ•¸é‡è¼ƒå¤š: ${gameState.world.size}/${gameState.maxLoadedBlocks}`);
            }
        }

        // å•Ÿå‹•éŠæˆ²
        window.addEventListener('load', startGame);
        if (document.readyState === 'complete') {
            startGame();
        }
    </script>
</body>
</html>
